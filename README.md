# optiongen
[![GoDoc](https://godoc.org/github.com/timestee/optiongen?status.svg)](https://godoc.org/github.com/timestee/optiongen)
[![Go Report Card](https://goreportcard.com/badge/github.com/timestee/optiongen)](https://goreportcard.com/report/github.com/timestee/optiongen)[![Sourcegraph](https://sourcegraph.com/github.com/timestee/optiongen/-/badge.svg)](https://sourcegraph.com/github.com/timestee/optiongen?badge)



optionGen is a fork of [XSAM/optionGen](https://github.com/XSAM/optionGen), a tool to generate go Struct option for test, mock or more flexible. The purpose of this fork is to provide more powerful and flexible option generation. 

## Functional Options
Functional options are an idiomatic way of creating APIs with options on types. The initial idea for this design pattern can be found in an article published by Rob Pike called [Self-referential functions and the design of options](https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html).

## Install
Install using go get, and this will build the optionGen binary in $GOPATH/bin.
```bash
go get github.com/timestee/optiongen/...
```

optionGen require [goimports](https://godoc.org/golang.org/x/tools/cmd/goimports) to format code which is generated. So you may confirm that `goimports` has been installed

```bash
go get golang.org/x/tools/cmd/goimports
```

## Using optionGen
To generate struct option, you need write a function declaration to tell optionGen how to generate.struct name and `OptionDeclareWithDefault` suffix. In this function, just return a variable which type is `map[string]interface{}`.

The key of the map means option name, and the value of the map should consist of two parts, one for option type(except func type), and the other option default value.

### Flag
- `new_func`, Struct New function name.
- `option_with_struct_name`, option name should contain struct name

### Filed Property
- `@#1`,`@#2`
field with tag `@#` will as Struct New Function Parameter, not gen option function

- `@protected`
field with tag `@protected` will not gen option function


Here is an example.
```go
//go:generate optiongen --option_with_struct_name=false --new_func=NewFuncNameSpecified
func ConfigOptionDeclareWithDefault() interface{} {
	return map[string]interface{}{
		// test comment 1
		// test comment 2
		"TestNil":           nil, // test comment 3
		"TestInt":           32,  // @MethodComment(这里是函数注释1) @MethodComment(这里是函数注释2)
		"TestInt64":         int64(32),
		"TestSliceInt":      []int{1, 2, 3},
		"TestSliceInt64":    []int64{1, 2, 3},
		"TestSliceString":   []string{"test1", "test2"},
		"TestSliceBool":     []bool{false, true},
		"TestSliceIntNil":   []int(nil),
		"TestSliceByte":     []byte(nil),
		"TestSliceIntEmpty": []int{},

		"TestMapIntInt":       map[int]int{1: 1, 2: 2, 3: 3},
		"TestMapIntString":    map[int]string{1: "test"},
		"TestMapStringInt":    map[string]int{"test": 1},
		"TestMapStringString": map[string]string{"test": "test"},

		"TestString": "Meow",
		"Food":       (*string)(nil),
		"Walk": func() {
			log.Println("Walking")
		},
		"TestNilFunc":             (func())(nil), // 中文1
		"TestParamterInt@#1":      false,         // reserved parameter 1
		"TestParamterStr@#2":      "",            // reserved parameter 2
		"TestProtected@protected": []byte(nil),
	}
}
```
```go
// Code generated by optiongen. DO NOT EDIT.
// optiongen: github.com/timestee/optiongen

package example

import "log"

// Google Public DNS provides two distinct DoH APIs at these endpoints
// Using the GET method can reduce latency, as it is cached more effectively.
// RFC 8484 GET requests must have a ?dns= query parameter with a Base64Url encoded DNS message. The GET method is the only method supported for the JSON API.

type Config struct {
	// test comment 1
	// test comment 2
	TestNil             interface{} // test comment 3
	TestInt             int
	TestInt64           int64
	TestSliceInt        []int
	TestSliceInt64      []int64
	TestSliceString     []string
	TestSliceBool       []bool
	TestSliceIntNil     []int
	TestSliceByte       []byte
	TestSliceIntEmpty   []int
	TestMapIntInt       map[int]int
	TestMapIntString    map[int]string
	TestMapStringInt    map[string]int
	TestMapStringString map[string]string
	TestString          string
	Food                *string
	Walk                func()
	TestNilFunc         func() // 中文1
	TestProtected       []byte
	TestParamterInt     bool   // reserved parameter 1
	TestParamterStr     string // reserved parameter 2
}

func (cc *Config) SetOption(opt ConfigOption) {
	_ = opt(cc)
}

func (cc *Config) ApplyOption(opts ...ConfigOption) {
	for _, opt := range opts {
		_ = opt(cc)
	}
}

func (cc *Config) GetSetOption(opt ConfigOption) ConfigOption {
	return opt(cc)
}

type ConfigOption func(cc *Config) ConfigOption

func WithTestNil(v interface{}) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestNil
		cc.TestNil = v
		return WithTestNil(previous)
	}
}

// 这里是函数注释1
// 这里是函数注释2
func WithTestInt(v int) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestInt
		cc.TestInt = v
		return WithTestInt(previous)
	}
}

func WithTestInt64(v int64) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestInt64
		cc.TestInt64 = v
		return WithTestInt64(previous)
	}
}

func WithTestSliceInt(v ...int) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestSliceInt
		cc.TestSliceInt = v
		return WithTestSliceInt(previous...)
	}
}

func WithTestSliceInt64(v ...int64) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestSliceInt64
		cc.TestSliceInt64 = v
		return WithTestSliceInt64(previous...)
	}
}

func WithTestSliceString(v ...string) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestSliceString
		cc.TestSliceString = v
		return WithTestSliceString(previous...)
	}
}

func WithTestSliceBool(v ...bool) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestSliceBool
		cc.TestSliceBool = v
		return WithTestSliceBool(previous...)
	}
}

func WithTestSliceIntNil(v ...int) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestSliceIntNil
		cc.TestSliceIntNil = v
		return WithTestSliceIntNil(previous...)
	}
}

func WithTestSliceByte(v []byte) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestSliceByte
		cc.TestSliceByte = v
		return WithTestSliceByte(previous)
	}
}

func WithTestSliceIntEmpty(v ...int) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestSliceIntEmpty
		cc.TestSliceIntEmpty = v
		return WithTestSliceIntEmpty(previous...)
	}
}

func WithTestMapIntInt(v map[int]int) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestMapIntInt
		cc.TestMapIntInt = v
		return WithTestMapIntInt(previous)
	}
}

func WithTestMapIntString(v map[int]string) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestMapIntString
		cc.TestMapIntString = v
		return WithTestMapIntString(previous)
	}
}

func WithTestMapStringInt(v map[string]int) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestMapStringInt
		cc.TestMapStringInt = v
		return WithTestMapStringInt(previous)
	}
}

func WithTestMapStringString(v map[string]string) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestMapStringString
		cc.TestMapStringString = v
		return WithTestMapStringString(previous)
	}
}

func WithTestString(v string) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestString
		cc.TestString = v
		return WithTestString(previous)
	}
}

func WithFood(v *string) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.Food
		cc.Food = v
		return WithFood(previous)
	}
}

func WithWalk(v func()) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.Walk
		cc.Walk = v
		return WithWalk(previous)
	}
}

func WithTestNilFunc(v func()) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.TestNilFunc
		cc.TestNilFunc = v
		return WithTestNilFunc(previous)
	}
}

func NewFuncNameSpecified(testParamterInt bool, testParamterStr string, opts ...ConfigOption) *Config {
	cc := newDefaultConfig()
	cc.TestParamterInt = testParamterInt
	cc.TestParamterStr = testParamterStr

	for _, opt := range opts {
		_ = opt(cc)
	}
	if watchDogConfig != nil {
		watchDogConfig(cc)
	}
	return cc
}

func InstallConfigWatchDog(dog func(cc *Config)) {
	watchDogConfig = dog
}

var watchDogConfig func(cc *Config)

func newDefaultConfig() *Config {

	cc := &Config{
		TestProtected:   nil,
		TestParamterInt: false,
		TestParamterStr: "",
	}

	for _, opt := range [...]ConfigOption{
		WithTestNil(nil),
		WithTestInt(32),
		WithTestInt64(32),
		WithTestSliceInt([]int{1, 2, 3}...),
		WithTestSliceInt64([]int64{1, 2, 3}...),
		WithTestSliceString([]string{"test1", "test2"}...),
		WithTestSliceBool([]bool{false, true}...),
		WithTestSliceIntNil(nil...),
		WithTestSliceByte(nil),
		WithTestSliceIntEmpty(nil...),
		WithTestMapIntInt(map[int]int{1: 1, 2: 2, 3: 3}),
		WithTestMapIntString(map[int]string{1: "test"}),
		WithTestMapStringInt(map[string]int{"test": 1}),
		WithTestMapStringString(map[string]string{"test": "test"}),
		WithTestString("Meow"),
		WithFood(nil),
		WithWalk(func() {
			log.Println("Walking")
		}),
		WithTestNilFunc(nil),
	} {
		_ = opt(cc)
	}

	return cc
}

```

See a complete example in the [example](https://github.com/timestee/optionGen/blob/master/example/cat.go) directory.
